#!/bin/sh

# --------------------------------------------------------------------------
# This is the script to create the unicode chars property table
# Originally written by Dimitry Golubovsky (dimitry@golubovsky.org) as part
# of the Partial Unicode Support patch, adopted for use with GHC.
# License: see libraries/base/LICENSE in the GHC source code
#
# Adopted for use with PureScript.
# -------------------------------------------------------------------------

############################################################
## The script reads the file from the standard input,     ##
## and outputs PureScript code into the standard output.  ##
## The PureScript code contains the chars property table, ##
## and basic functions to access properties.              ##
############################################################

# Output the file header

echo "-----------------------------------------------------------"
echo "-- This is an automatically generated file: do not edit"
echo "-- Generated by `basename $0` at `date`"
echo "-----------------------------------------------------------"
echo

# Define structures

cat <<EOF

module Data.Char.Internal where

import Prelude

import Data.Foldable
import Data.Maybe

-- Unicode general categories, listed in the same order as in the Unicode
-- standard. This must be the same order as in GHC.Unicode.
data UnicodeCategory = NUMCAT_LU  -- Letter, Uppercase
                     | NUMCAT_LL  -- Letter, Lowercase
                     | NUMCAT_LT  -- Letter, Titlecase
                     | NUMCAT_LM  -- Letter, Modifier
                     | NUMCAT_LO  -- Letter, Other
                     | NUMCAT_MN  -- Mark, Non-Spacing
                     | NUMCAT_MC  -- Mark, Spacing Combining
                     | NUMCAT_ME  -- Mark, Enclosing
                     | NUMCAT_ND  -- Number, Decimal
                     | NUMCAT_NL  -- Number, Letter
                     | NUMCAT_NO  -- Number, Other
                     | NUMCAT_PC  -- Punctuation, Connector
                     | NUMCAT_PD  -- Punctuation, Dash
                     | NUMCAT_PS  -- Punctuation, Open
                     | NUMCAT_PE  -- Punctuation, Close
                     | NUMCAT_PI  -- Punctuation, Initial quote
                     | NUMCAT_PF  -- Punctuation, Final quote
                     | NUMCAT_PO  -- Punctuation, Other
                     | NUMCAT_SM  -- Symbol, Math
                     | NUMCAT_SC  -- Symbol, Currency
                     | NUMCAT_SK  -- Symbol, Modifier
                     | NUMCAT_SO  -- Symbol, Other
                     | NUMCAT_ZS  -- Separator, Space
                     | NUMCAT_ZL  -- Separator, Line
                     | NUMCAT_ZP  -- Separator, Paragraph
                     | NUMCAT_CC  -- Other, Control
                     | NUMCAT_CF  -- Other, Format
                     | NUMCAT_CS  -- Other, Surrogate
                     | NUMCAT_CO  -- Other, Private Use
                     | NUMCAT_CN  -- Other, Not Assigned

instance showUnicodeCategory :: Show UnicodeCategory where
    show NUMCAT_LU = "NUMCAT_LU"
    show NUMCAT_LL = "NUMCAT_LL"
    show NUMCAT_LT = "NUMCAT_LT"
    show NUMCAT_LM = "NUMCAT_LM"
    show NUMCAT_LO = "NUMCAT_LO"
    show NUMCAT_MN = "NUMCAT_MN"
    show NUMCAT_MC = "NUMCAT_MC"
    show NUMCAT_ME = "NUMCAT_ME"
    show NUMCAT_ND = "NUMCAT_ND"
    show NUMCAT_NL = "NUMCAT_NL"
    show NUMCAT_NO = "NUMCAT_NO"
    show NUMCAT_PC = "NUMCAT_PC"
    show NUMCAT_PD = "NUMCAT_PD"
    show NUMCAT_PS = "NUMCAT_PS"
    show NUMCAT_PE = "NUMCAT_PE"
    show NUMCAT_PI = "NUMCAT_PI"
    show NUMCAT_PF = "NUMCAT_PF"
    show NUMCAT_PO = "NUMCAT_PO"
    show NUMCAT_SM = "NUMCAT_SM"
    show NUMCAT_SC = "NUMCAT_SC"
    show NUMCAT_SK = "NUMCAT_SK"
    show NUMCAT_SO = "NUMCAT_SO"
    show NUMCAT_ZS = "NUMCAT_ZS"
    show NUMCAT_ZL = "NUMCAT_ZL"
    show NUMCAT_ZP = "NUMCAT_ZP"
    show NUMCAT_CC = "NUMCAT_CC"
    show NUMCAT_CF = "NUMCAT_CF"
    show NUMCAT_CS = "NUMCAT_CS"
    show NUMCAT_CO = "NUMCAT_CO"
    show NUMCAT_CN = "NUMCAT_CN"

newtype ConversionRule = ConversionRule { category   :: Int
                                        , unicodeCat :: UnicodeCategory
                                        , possible   :: Int
                                        , updist     :: Int
                                        , lowdist    :: Int
                                        , titledist  :: Int
                                        }

instance showConversionRule :: Show ConversionRule where
    show (ConversionRule rule) = "ConversionRule { category: " <> show rule.category
                              <> ", unicodeCat: " <> show rule.unicodeCat
                              <> ", possible: " <> show rule.possible
                              <> ", updist: " <> show rule.updist
                              <> ", lowdist: " <> show rule.lowdist
                              <> ", titledist: " <> show rule.titledist
                              <> " }"

newtype CharBlock = CharBlock { start    :: Int
                              , length   :: Int
                              , convRule :: ConversionRule
                              }

instance showCharBlock :: Show CharBlock where
    show (CharBlock rule) = "CharBlock { start: " <> show rule.start
                         <> ", length: " <> show rule.length
                         <> ", convRule: " <> show rule.convRule
                         <> " }"


EOF

# Convert the stdin file to the C table

awk '
BEGIN {
	FS = ";"
	catidx = 0
	rulidx = 0
	blockidx = 0
	cblckidx = 0
	sblckidx = 0
	blockb = -1
	blockl = 0
	digs = "0123456789ABCDEF"
	for (i = 0; i < 16; i++)
	{
		hex[substr(digs, i+1, 1)] = i;
	}
}
function em1(a)
{
	if(a=="") return "-1"
	return "0x"a
}
function h2d(a)
{
	l=length(a)
	acc=0
	for(i=1;i<=l;i++)
	{
		acc=acc*16+hex[substr(a,i,1)];
	}
	return acc
}
function dumpblock()
{
	blkd = "CharBlock { start: " blockb ", length: " blockl ", convRule: rule" rules[blockr] " }"
	blocks[blockidx] = blkd
	blockidx++
	if (blockb <= 256)
	{
		lat1idx++
	}

	split(blockr, rsp, ",")
	if(substr(rsp[3], 12, 1) == "1")
	{
		cblcks[cblckidx]=blkd
		cblckidx++
	}

	split(rsp[1], rsp_cat_split, " ")
	if(rsp_cat_split[3] == "gencatZS")
	{
		sblcks[sblckidx]=blkd
		sblckidx++
	}

	blockb=self
	blockl=1
	blockr=rule
}
{
	name=$2
	cat=toupper($3)
	self=h2d($1)
	up=h2d($13)
	low=h2d($14)
	title=h2d($15)
	convpos=1
	if((up==0)&&(low==0)&&(title==0)) convpos=0
	if(up==0) up=self
	if(low==0) low=self
	if(title==0) title=self
	updist=up-self
	lowdist=low-self
	titledist=title-self
	rule = \
		"{ category: gencat" cat \
		", unicodeCat: NUMCAT_" cat \
		( (convpos==1) ? \
				(", possible: 1" \
				 ", updist: " updist \
				 ", lowdist: " lowdist \
				 ", titledist: " titledist) : \
				(", possible: 0, updist: 0, lowdist: 0, titledist: 0")) \
		" }"
	if(cats[cat]=="")
	{
		cats[cat]=(2^catidx);
		catidx++;
	}
	if(rules[rule]=="")
	{
		rules[rule]=rulidx;
		rulidx++;
	}
	if(blockb==-1)
	{
		blockb=self
		blockl=1
		blockr=rule
	}
	else
	{
		if (index(name,"First>")!=0)
		{
			dumpblock()
		}
		else if (index(name,"Last>")!=0)
		{
			blockl+=(self-blockb)
		}
		else if((self==blockb+blockl)&&(rule==blockr)) blockl++
		else
		{
			dumpblock()
		}
	}
}
END {
	dumpblock()
	for(c in cats)
	{
		print "gencat" c " :: Int"
		print "gencat" c " = " cats[c] "\n"
	}

	print "maxUniChar :: Int"
	print "maxUniChar = " self "\n"

	print "numBlocks :: Int"
	print "numBlocks = " blockidx "\n"

	print "numConvBlocks :: Int"
	print "numConvBlocks = " cblckidx "\n"

	print "numSpaceBlocks :: Int"
	print "numSpaceBlocks = " sblckidx "\n"

	print "numLat1Blocks :: Int"
	print "numLat1Blocks = " lat1idx "\n"

	print "numRules :: Int"
	print "numRules = " rulidx "\n"

	for(r in rules)
	{
		print "rule" rules[r] " :: ConversionRule"
		print "rule" rules[r] " = ConversionRule " r "\n"
	}

	print "allchars :: Array CharBlock"
	printf "allchars = [ "
	for(i = 0; i < blockidx; i++)
	{
		printf (i>0) ? "           , " : ""
		printf blocks[i] "\n"
	}
	print "           ]\n"

	print "convchars :: Array CharBlock"
	printf "convchars = [ "
	for(i = 0; i < cblckidx; i++)
	{
		printf (i>0) ? "            , " : ""
		printf cblcks[i] "\n"
	}
	print "            ]\n"

	print "spacechars :: Array CharBlock"
	printf "spacechars = [ "
	for(i = 0; i < sblckidx; i++)
	{
		printf (i>0) ? "             , " : ""
		printf sblcks[i] "\n"
	}
	print "             ]\n"
}
'
#	Output the C procedures code

cat <<EOF

-- Obtain the reference to character rule by doing
-- binary search over the specified array of blocks.
-- To make checkattr shorter, the address of
-- nullrule is returned if the search fails:
-- this rule defines no category and no conversion
-- distances. The compare function returns 0 when
-- key->start is within the block. Otherwise
-- result of comparison of key->start and start of the
-- current block is returned as usual.

nullrule :: ConversionRule
nullrule = ConversionRule { category: gencatLU, unicodeCat: NUMCAT_CN, possible: 0, updist: 0, lowdist: 0, titledist: 0 }

blkCmp :: CharBlock -> CharBlock -> Int
blkCmp (CharBlock key) (CharBlock cur)
    | key.start >= cur.start && key.start < (cur.start + cur.length) =  0
    | key.start > cur.start                                          =  1
    | otherwise                                                      = -1


-- TODO: This might be better if it returned Nothing instead of the nullrule.
getRule :: Array CharBlock -> Int -> Int -> Maybe ConversionRule
getRule blocks unichar size =
    -- TODO: does using the nullrule make sense here?
    let key = CharBlock { start: unichar, length: 1, convRule: nullrule }
        maybeCharBlock = bsearch key blocks size blkCmp
    in case maybeCharBlock of
        Nothing -> Nothing
        Just (CharBlock charBlock) -> Just charBlock.convRule

-- TODO: This isn't actually a binary search...
--
-- The third argument is a  size.  It says to only look at this many elements
-- in the array.  There are times when we don't want to look at ALL the
-- elements, but only a subset.
bsearch :: forall a . a -> Array a -> Int -> (a -> a -> Int) -> Maybe a
bsearch a array _ compare = find (\testA -> compare a testA == 0) array


-- Check whether a character (internal code) has certain attributes.
-- Attributes (category flags) may be ORed. The function ANDs
-- character category flags and the mask and returns the result.
-- If the character belongs to one of the categories requested,
-- the result will be nonzero.
checkAttr :: Array Int -> Int -> Boolean
checkAttr categories char =
    let numOfBlocks = if char < 256 then numLat1Blocks else numBlocks
        maybeConversionRule = getRule allchars char numOfBlocks
    in case maybeConversionRule of
            Nothing -> false
            Just (ConversionRule rule) -> elem rule.category categories

checkAttrS :: Array Int -> Int -> Boolean
checkAttrS categories char =
    let maybeConversionRule = getRule spacechars char numSpaceBlocks
    in case maybeConversionRule of
            Nothing -> false
            Just (ConversionRule rule) -> elem rule.category categories

uIswcntrl :: Int -> Boolean
uIswcntrl = checkAttr [ gencatCC ]

uIswprint :: Int -> Boolean
uIswprint = checkAttr
    [ gencatMC, gencatNO, gencatSK, gencatME, gencatND, gencatPO
    , gencatLT, gencatPC, gencatSM, gencatZS, gencatLU, gencatPD
    , gencatSO, gencatPE, gencatPF, gencatPS, gencatSC, gencatLL
    , gencatLM, gencatPI, gencatNL, gencatMN, gencatLO
    ]

uIswupper :: Int -> Boolean
uIswupper = checkAttr [ gencatLU, gencatLT ]

uIswlower :: Int -> Boolean
uIswlower = checkAttr [ gencatLL ]

uIswalpha :: Int -> Boolean
uIswalpha = checkAttr [ gencatLL, gencatLU, gencatLT, gencatLM, gencatLO ]

uIswdigit :: Int -> Boolean
uIswdigit = checkAttr [ gencatND ]

uIswalnum :: Int -> Boolean
uIswalnum = checkAttr
    [ gencatLT, gencatLU, gencatLL, gencatLM, gencatLO, gencatMC, gencatME
    , gencatMN, gencatNO, gencatND, gencatNL
    ]

uIswspace :: Int -> Boolean
uIswspace = checkAttrS [ gencatZS ]

--
-- Define predicate functions for some combinations of categories.
--

caseConv :: (ConversionRule -> Int) -> Int -> Int
caseConv f char =
    let maybeConversionRule = getRule convchars char numConvBlocks
    in case maybeConversionRule of
        Nothing -> char
        Just conversionRule -> char + f conversionRule

uTowupper :: Int -> Int
uTowupper = caseConv (\(ConversionRule rule) -> rule.updist)

uTowlower :: Int -> Int
uTowlower = caseConv (\(ConversionRule rule) -> rule.lowdist)

uTowtitle :: Int -> Int
uTowtitle = caseConv (\(ConversionRule rule) -> rule.titledist)

uGencat :: Int -> Maybe UnicodeCategory
uGencat char =
    let conversionRule = getRule allchars char numBlocks
    in map (\(ConversionRule rule) -> rule.unicodeCat) conversionRule

EOF
